"""
Script Manager module
-----------------
Manages the storage and retrieval of LLM-generated Python scripts
"""

import os
import uuid
from typing import Dict, Any, Optional
from datetime import datetime

class ScriptManager:
    """
    Manages storage and retrieval of scripts generated by the LLM
    """
    
    def __init__(self, script_dir: Optional[str] = None):
        """
        Initialize the script manager
        
        Args:
            script_dir: Directory to store scripts (default: src/script)
        """
        self.script_dir = script_dir or os.path.join('src', 'script')
        os.makedirs(self.script_dir, exist_ok=True)
    
    def save_script(self, script: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """
        Save a script to the script directory
        
        Args:
            script: The Python script to save
            metadata: Optional metadata to include as comments
            
        Returns:
            str: The ID of the saved script
        """
        # Create a unique ID for this script
        script_id = str(uuid.uuid4())[:8]
        timestamp = datetime.now().isoformat()
        
        # Prepare script content with metadata as comments
        script_content = f"""\"\"\"
Auto-generated script {script_id}
Generated on: {timestamp}
\"\"\"
{script}
"""
        
        # Save the script
        file_path = os.path.join(self.script_dir, f"script_{script_id}.py")
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(script_content)
            
        return script_id
        
    def get_script(self, script_id: str) -> Optional[str]:
        """
        Get a script by ID
        
        Args:
            script_id: The ID of the script to retrieve
            
        Returns:
            Optional[str]: The script if found, None otherwise
        """
        file_path = os.path.join(self.script_dir, f"script_{script_id}.py")
        if not os.path.exists(file_path):
            return None
            
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
            
    def list_scripts(self) -> Dict[str, str]:
        """
        List all available scripts
        
        Returns:
            Dict[str, str]: Dictionary of script IDs and their paths
        """
        scripts: Dict[str, str] = {}
        
        if not os.path.exists(self.script_dir):
            return scripts
            
        for filename in os.listdir(self.script_dir):
            if filename.startswith("script_") and filename.endswith(".py"):
                script_id = filename[7:-3]  # Remove "script_" prefix and ".py" extension
                scripts[script_id] = os.path.join(self.script_dir, filename)
                
        return scripts
        
    def cleanup_old_scripts(self, max_age_hours: int = 24) -> int:
        """
        Clean up old script files
        
        Args:
            max_age_hours: Maximum age of scripts to keep in hours
            
        Returns:
            int: Number of scripts deleted
        """
        import time
        
        now = time.time()
        max_age_seconds = max_age_hours * 3600
        deleted_count = 0
        
        # Files to preserve
        protected_files = ['.gitkeep']
        
        if not os.path.exists(self.script_dir):
            return 0
            
        for filename in os.listdir(self.script_dir):
            if filename in protected_files:
                continue
                
            file_path = os.path.join(self.script_dir, filename)
            if os.path.isfile(file_path):
                try:
                    os.remove(file_path)
                    deleted_count += 1
                except (PermissionError, OSError) as e:
                    print(f"Warning: Could not delete script file {file_path}: {e}")
    
        return deleted_count
