"""
Script Executor module
------------------
Safely executes Python scripts generated by the LLM
"""

import os
import pandas as pd
import numpy as np
from typing import Tuple, List, Dict, Any, Optional, Hashable
from src.controller.security_manager import SecurityManager
from src.controller.script_manager import ScriptManager
from src.controller.file_manager import FileManager

class ScriptExecutor:
    """
    Executes Python scripts generated by the LLM on spreadsheet data
    """
    
    def __init__(self, script_dir: Optional[str] = None):
        """
        Initialize the script executor
        
        Args:
            script_dir: Optional directory path for saving scripts
        """
        self.security_manager = SecurityManager()
        self.script_dir = script_dir or os.path.join('src', 'script')
        self.script_manager = ScriptManager(self.script_dir)
    
    def execute_script(self, script: str, spreadsheet_df: pd.DataFrame, file_manager: Optional[FileManager] = None) -> Tuple[pd.DataFrame, List[List[int]]]:
        """
        Execute a Python script on spreadsheet data

        Args:
            script: The Python script generated by LLM
            spreadsheet_df: The pandas DataFrame containing spreadsheet data
            file_manager: Optional FileManager to save script for reference

        Returns:
            Tuple[pd.DataFrame, List[List[int]]]: Modified DataFrame and list of modified cells
        """
        # Validate script for security
        if not self.security_manager.validate_script(script):
            raise ValueError("Script validation failed due to security concerns")
              # Create a unique ID for this script
        import uuid
        script_id = str(uuid.uuid4())[:8]
        
        # Save script to src/script directory
        script_dir = self.script_dir
        os.makedirs(script_dir, exist_ok=True)
        script_path = os.path.join(script_dir, f"script_{script_id}.py")
        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(script)
            
        # Save script metadata to json directory for reference if file_manager is provided
        if file_manager:
            file_manager.save_json_data({
                'script': script,
                'script_id': script_id,
                'timestamp': str(pd.Timestamp.now()),
                'columns': spreadsheet_df.columns.tolist(),
                'rows': len(spreadsheet_df)
            }, f"script_{script_id}")
        
        # Track original data for determining modifications
        orig_columns = set(spreadsheet_df.columns)
        # Ensure keys are str for type compatibility
        filled_df: pd.DataFrame = spreadsheet_df.copy().fillna(value=np.nan)
        data_dict: Dict[Hashable, Any] = filled_df.to_dict()
        orig_values = {str(k): v for k, v in data_dict.items()}
        
        # Create a sandbox environment
        sandbox_globals = self._create_sandbox(spreadsheet_df)
        
        try:
            # Execute script
            exec(script, sandbox_globals)
            
            # Get the modified dataframe
            modified_df = sandbox_globals.get('df', spreadsheet_df)
            
            # Find modified cells
            modified_cells = self._find_modified_cells(
                orig_df=spreadsheet_df, 
                orig_columns=orig_columns,
                orig_values=orig_values, 
                new_df=modified_df
            )
            
            return modified_df, modified_cells
            
        except Exception as e:
            raise RuntimeError(f"Error executing script: {str(e)}")
    
    def validate_script_safety(self, script: str) -> bool:
        """
        Validate that a script is safe to execute

        Args:
            script: The Python script to validate

        Returns:
            bool: True if the script is safe, False otherwise
        """
        return self.security_manager.validate_script(script)
    
    def _create_sandbox(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        Create a sandbox environment for script execution

        Args:
            df: The pandas DataFrame to operate on

        Returns:
            Dict[str, Any]: Dictionary of global variables for the sandbox
        """
        # Create a copy of the dataframe to avoid modifying the original
        sandbox_df = df.copy()
        
        # Define allowed modules and functions
        sandbox: Dict[str, Any] = {
            'df': sandbox_df,
            'pd': pd,
            'np': np,
            'print': print
        }
        
        return sandbox
    
    def _find_modified_cells(self, orig_df: pd.DataFrame, orig_columns: set[str], orig_values: Dict[str, Any], new_df: pd.DataFrame) -> List[List[int]]:
        """
        Find cells that were modified by the script

        Args:
            orig_df: Original DataFrame
            orig_columns: Set of original column names
            orig_values: Dict of original values
            new_df: Modified DataFrame

        Returns:
            List[List[int]]: List of [row, col] coordinates for modified cells
        """
        modified_cells: List[List[int]] = []
        
        # Check for new columns
        new_columns = set(new_df.columns) - orig_columns
        for col_name in new_columns:
            col_idx = list(new_df.columns).index(col_name)
            for row_idx in range(len(new_df)):
                modified_cells.append([row_idx, col_idx])
        
        # Check for modified values in existing columns
        for col_name in orig_columns:
            if col_name in new_df.columns:
                col_idx = list(new_df.columns).index(col_name)
                orig_col_idx = list(orig_df.columns).index(col_name)
                
                for row_idx in range(min(len(orig_df), len(new_df))):
                    # Check for equality considering NaN values
                    orig_val: Any = orig_df.iat[row_idx, orig_col_idx]
                    new_val: Any = new_df.iat[row_idx, col_idx]
                    
                    if pd.isna(orig_val) and pd.isna(new_val):
                        continue  # Both NaN, not modified
                    elif pd.isna(orig_val) or pd.isna(new_val):
                        # One is NaN and the other isn't, they're different
                        modified_cells.append([row_idx, col_idx])
                    elif orig_val != new_val:
                        # Both are non-NaN but have different values
                        modified_cells.append([row_idx, col_idx])
        
        return modified_cells
