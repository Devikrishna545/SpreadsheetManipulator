"""
Script Executor module
------------------
Safely executes Python scripts generated by the LLM
"""

import os
import pandas as pd
import numpy as np
import re
import ast
import uuid
from typing import Tuple, List, Dict, Any

from src.controller.security_manager import SecurityManager
from src.controller.script_manager import ScriptManager


class ScriptExecutor:
    """
    Executes Python scripts generated by the LLM on spreadsheet data
    """
    
    def __init__(self, script_dir=None):
        """
        Initialize the script executor
        
        Args:
            script_dir: Optional directory path for saving scripts
        """
        self.security_manager = SecurityManager()
        self.script_dir = script_dir or os.path.join('src', 'script')
        self.script_manager = ScriptManager(script_dir)
      
    def execute_script(self, script: str, spreadsheet_df: pd.DataFrame, file_manager=None) -> Tuple[pd.DataFrame, List[List[int]]]:
        """
        Execute a Python script on spreadsheet data

        Args:
            script: The Python script generated by LLM
            spreadsheet_df: The pandas DataFrame containing spreadsheet data
            file_manager: Optional FileManager to save script for reference

        Returns:
            Tuple[pd.DataFrame, List[List[int]]]: Modified DataFrame and list of modified cells
        """
        # Validate script for security
        if not self.security_manager.validate_script(script):
            raise ValueError("Script validation failed due to security concerns")
              # Create a unique ID for this script
        import uuid
        script_id = str(uuid.uuid4())[:8]
        
        # Save script to src/script directory
        script_dir = self.script_dir
        os.makedirs(script_dir, exist_ok=True)
        script_path = os.path.join(script_dir, f"script_{script_id}.py")
        with open(script_path, 'w', encoding='utf-8') as f:
            f.write(script)
            
        # Save script metadata to json directory for reference if file_manager is provided
        if file_manager:
            file_manager.save_json_data({
                'script': script,
                'script_id': script_id,
                'timestamp': str(pd.Timestamp.now()),
                'columns': spreadsheet_df.columns.tolist(),
                'rows': len(spreadsheet_df)
            }, f"script_{script_id}")
        
        # Track original data for determining modifications
        orig_columns = set(spreadsheet_df.columns)
        orig_values = spreadsheet_df.copy().fillna(np.nan).to_dict()
        
        # Create a sandbox environment
        sandbox_globals = self._create_sandbox(spreadsheet_df)
        
        try:
            # Execute script
            exec(script, sandbox_globals)
            
            # Get the modified dataframe
            modified_df = sandbox_globals.get('df', spreadsheet_df)
            
            # Find modified cells
            modified_cells = self._find_modified_cells(
                orig_df=spreadsheet_df, 
                orig_columns=orig_columns,
                orig_values=orig_values, 
                new_df=modified_df
            )
            
            return modified_df, modified_cells
            
        except Exception as e:
            raise RuntimeError(f"Error executing script: {str(e)}")
    
    def validate_script_safety(self, script: str) -> bool:
        """
        Validate that a script is safe to execute

        Args:
            script: The Python script to validate

        Returns:
            bool: True if the script is safe, False otherwise
        """
        return self.security_manager.validate_script(script)
    
    def _create_sandbox(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        Create a sandbox environment for script execution

        Args:
            df: The pandas DataFrame to operate on

        Returns:
            Dict[str, Any]: Dictionary of global variables for the sandbox
        """
        # Create a copy of the dataframe to avoid modifying the original
        sandbox_df = df.copy()
        
        # Define allowed modules and functions
        sandbox = {
            'df': sandbox_df,
            'pd': pd,
            'np': np,
            'print': print
        }
        
        return sandbox
    
    def _find_modified_cells(self, orig_df: pd.DataFrame, orig_columns: set, orig_values: Dict, new_df: pd.DataFrame) -> List[List[int]]:
        """
        Find cells that were modified by the script

        Args:
            orig_df: Original DataFrame
            orig_columns: Set of original column names
            orig_values: Dict of original values
            new_df: Modified DataFrame

        Returns:
            List[List[int]]: List of [row, col] coordinates for modified cells
        """
        modified_cells = []
        
        # Check for new columns
        new_columns = set(new_df.columns) - orig_columns
        for col_name in new_columns:
            col_idx = new_df.columns.get_loc(col_name)
            for row_idx in range(len(new_df)):
                modified_cells.append([row_idx, col_idx])
        
        # Check for modified values in existing columns
        for col_name in orig_columns:
            if col_name in new_df.columns:
                col_idx = new_df.columns.get_loc(col_name)
                orig_col_idx = orig_df.columns.get_loc(col_name)
                
                for row_idx in range(min(len(orig_df), len(new_df))):
                    # Check for equality considering NaN values
                    orig_val = orig_df.iat[row_idx, orig_col_idx]
                    new_val = new_df.iat[row_idx, col_idx]
                    
                    if pd.isna(orig_val) and pd.isna(new_val):
                        continue  # Both NaN, not modified
                    
                    if pd.isna(orig_val) != pd.isna(new_val) or orig_val != new_val:
                        modified_cells.append([row_idx, col_idx])
        
        return modified_cells
